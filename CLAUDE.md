# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

钟馗 (Zhongkui) is a **local build performance analysis tool** for Bazel monorepos. It identifies build hotspots by:

1. **Profile Analysis**: Parsing Bazel profile JSON files to extract action execution times and metadata
2. **Diff Analysis**: Analyzing file changes to determine which Bazel packages are impacted
3. **Dependency Analysis**: Correlating file changes with affected actions and distributing build time across responsible packages
4. **Single Report Generation**: Generating actionable JSON and Markdown reports for immediate analysis

This is a **pure local tool** that works offline without requiring BEP infrastructure. Analysis results are consumed by external data products for further processing.

## Architecture

The codebase follows a modular architecture with clear separation of concerns:

```
src/
├── profile/     # Bazel profile JSON analysis and action extraction
├── bazel/       # Bazel query integration for accurate target-to-package mapping
├── diff/        # File change analysis and package mapping  
├── dependency/  # Action-to-package correlation and time distribution
├── hotspot/     # Report generation and recommendations
├── utils/       # Shared utilities (logging, etc.)
├── types.ts     # Core type definitions
└── index.ts     # CLI entry point
```

### Core Data Flow

1. `ProfileAnalyzer` extracts action timing data from Bazel profile JSON files
2. `DiffAnalyzer` processes git diff to identify changed files and their packages
3. `BazelQuery` provides accurate target-to-package mapping using `bazel query` commands
4. `DependencyAnalyzer` correlates actions with file changes using Bazel dependency graph, implementing sophisticated attribution logic for shared dependencies
5. `HotspotReporter` aggregates data and generates actionable reports

### Profile Analysis Details

**Bazel Profile Format**: The tool parses Chrome Tracing format JSON files generated by `bazel build --profile=profile.json`
- **Action Events**: Extracts events with `cat: "action"` and `ph: "X"` (complete events)
- **Target Extraction**: Uses regex patterns to extract Bazel targets from event names
- **Timing Data**: Converts microsecond timestamps to milliseconds for analysis
- **Metadata**: Extracts mnemonics, inputs, outputs when available in profile args

### Key Architecture Decisions

**Bazel Query Integration**: The `BazelQuery` class provides essential functionality:
- `mapActionToPackage()`: Maps action targets to owning packages using `bazel query --output=package`
- `getPackageDependencies()/getDependents()`: Builds dependency graph using `deps()` and `rdeps()` queries
- `getFilePackage()`: Determines file ownership using `rdeps(//..., file, 1)` queries
- Caching for performance optimization in large monorepos

**Attribution Algorithm**: Actions are attributed to packages using a two-tier process:
1. **Direct Attribution**: Actions in changed packages get full duration attribution
2. **Transitive Attribution**: Actions in dependent packages are recorded but their duration is attributed only to the changed packages that caused them
3. **Pure Attribution**: Total attributed time equals actual build time (no double-counting)

### Key Types

- `BazelAction`: Represents a single build action with timing and dependency data
- `FileChange`: Maps file changes to Bazel packages
- `PackageHotspot`: Aggregated statistics for package-level optimization insights
- `BuildAnalysis`: Complete analysis results for a single invocation

## Development Commands

```bash
# Build the project
npm run build

# Run in development mode  
npm run dev

# Run tests
npm run test
npm run test:watch

# Linting and type checking
npm run lint
npm run lint:fix
npm run typecheck
```

## Usage Patterns

### CLI Commands

```bash
# Generate a profile during build
bazel build --profile=profile.json //src/...

# Analyze the profile with target scope  
zhongkui analyze -p profile.json -t "//src/..." -r /path/to/repo

# Analyze specific targets
zhongkui analyze -p profile.json -t "//app:*" -r /path/to/repo
```

**Output**: Generates `report-{profileId}-{timestamp}.json` and `report-{profileId}-{timestamp}.md` files for consumption by external data products.

### Key Implementation Notes

- **Pure Local Tool**: No external dependencies on BEP infrastructure - works entirely offline with profile files
- **Profile-Based Analysis**: Parses standard Bazel profile JSON files generated with `--profile` flag
- **Target Scoping**: Analysis is limited to specified build targets using `-t` parameter, ensuring accurate dependency analysis within build scope
- **Pure Attribution Logic**: Build time is attributed only to packages that caused changes, ensuring total attributed time equals actual build time
- **Scoped Dependency Analysis**: `bazel query rdeps()` commands are scoped to target patterns to avoid analyzing irrelevant parts of the monorepo
- **Transitive Tracking**: Actions in dependent packages are tracked but not double-counted in time attribution
- **Package Detection**: Currently uses directory structure for package mapping; production implementation should parse BUILD files
- **Shared Dependency Handling**: When multiple changed packages contribute to an action, duration is split equally among them

## Future Implementation Areas

Key TODOs for production readiness:

1. **Profile Format Support**: Extend support for different Bazel profile formats and versions
2. **BUILD File Detection**: Replace stub package detection with actual BUILD file parsing  
3. **Performance Optimization**: Add caching and incremental analysis capabilities for large profiles
4. **Profile Validation**: Add validation for profile completeness and data quality
5. **Output Format Options**: Support additional output formats for different data product integrations

## Testing Strategy

- Unit tests for core algorithms (dependency analysis, time distribution)
- Integration tests for CLI workflows with sample profile files
- Performance tests for large monorepo scenarios and profile parsing

The architecture prioritizes modularity and testability to handle the complexity of large-scale build analysis. Output files are designed for consumption by external data analysis platforms.